<?php
/**
 * SimpleMedia.
 *
 * @copyright Erik Spaan & Axel Guckelsberger (ZKM)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package SimpleMedia
 * @author Erik Spaan & Axel Guckelsberger <erik@zikula.nl>.
 * @link https://github.com/zikula-ev/SimpleMedia
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.6.1 (http://modulestudio.de).
 */

/**
 * Upload handler implementation class.
 */
class SimpleMedia_UploadHandler extends SimpleMedia_Base_UploadHandler
{
    // feel free to add your upload handler enhancements here

    /**
     * @var array List of file types to be considered as audio.
     */
    protected $audioFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $videoFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $ebookFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $rawImageFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $geoFileTypes;

    /**
     * @var array List of file types to be considered as documents.
     */
    protected $documentFileTypes;

    /**
     * Constructor initialising the supported object types.
     */
    public function __construct()
    {
        parent::__construct();
        
        // see for instance http://en.wikipedia.org/wiki/List_of_file_formats
        $this->imageFileTypes = array('gif', 'jpeg', 'jpg', 'png', 'tif', 'tiff', 'bmp'); // raster images
        $this->audioFileTypes = array('aac', 'mp3', 'wav', 'aif', 'mid');
        $this->videoFileTypes = array('mpg', 'mpeg', 'mp4', 'mov', 'wmv', 'avi', 'swf', 'flv', 'rm', 'f4v', 'h264');
        $this->ebookFileTypes = array('epub', 'mobi');
        $this->rawImageFileTypes = array('dng', 'cr2', 'nef');
        $this->geoFileTypes = array('kml', 'gpx');

        $dtpFileTypes = array('qxd', 'fm', 'indd');
        $otherimageFileTypes = array('psd', 'eps', 'ps', 'ai', 'svg', 'odg', 'emf', 'dwg', 'dxf');
        $this->documentFileTypes = array_merge(
            array('pdf', 'doc', 'xls', 'ppt', 'docx', 'xlsx', 'pptx', 'odt', 'ods', 'odp', 'pages', 'numbers', 'key', 'keynote', 'txt', 'rtf', 'csv', 'tex'), 
            $otherimageFileTypes, $dtpFileTypes
        );
        // zip and other package files will go into other
		
		// use modvar in kBytes for file size in Bytes
        $this->allowedFileSizes = array('medium' => array('theFile' => ModUtil::getVar('SimpleMedia', 'maxUploadFileSize')*1024));
    }

    /**
     * Determines the allowed file extensions for a given object type.
     * OVERRIDE: using allowedExtensions
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fieldName  Name of upload field.
     * @param string $extension  Input file extension.
     *
     * @return array the list of allowed file extensions
     */
    protected function isAllowedFileExtension($objectType, $fieldName, $extension)
    {
        // determine the allowed extensions
        $allowedExtensions = array();
        switch ($objectType) {
            case 'medium':
                $allowedExtensions = explode(',', str_replace(' ', '', ModUtil::getVar('SimpleMedia', 'allowedExtensions')));
                    break;
        }
    
        if (count($allowedExtensions) > 0) {
            if (!in_array($extension, $allowedExtensions)) {
                return false;
            }
        }
    
        if (in_array($extension, $this->forbiddenFileTypes)) {
            return false;
        }
    
        return true;
    }
    
    /**
     * Read meta data from a certain file. 
     * OVERRIDE adding exif/iptc vars
     *
     * @param string $fileName  Name of file to be processed.
     * @param string $filePath  Path to file to be processed.
     *
     * @return array collected meta data
     */
    public function readMetaDataForFile($fileName, $filePath)
    {
        // call parent class
        $meta = parent::readMetaDataForFile($fileName, $filePath);

        // isImage is already in parent
        $meta['isAudio'] = (in_array($meta['extension'], $this->audioFileTypes) ? true : false);
        $meta['isVideo'] = (in_array($meta['extension'], $this->videoFileTypes) ? true : false);
        $meta['isEbook'] = (in_array($meta['extension'], $this->ebookFileTypes) ? true : false);
        $meta['isRawImage'] = (in_array($meta['extension'], $this->rawImageFileTypes) ? true : false);
        $meta['isGeo'] = (in_array($meta['extension'], $this->geoFileTypes) ? true : false);
        $meta['isDoc'] = (in_array($meta['extension'], $this->documentFileTypes) ? true : false);
        // Add extra identification for pdf files, they are doc as well as pdf.
        $meta['isPdf'] = ($meta['extension'] == 'pdf') ? true : false;

//        $iptc = new SimpleMedia_Util_Iptc($filePath);
//        print_r($iptc->fetchAll(SimpleMedia_Util_Iptc::KEYWORDS));
//        print_r($iptc->dump());
        
/*
1	IMAGETYPE_GIF
2	IMAGETYPE_JPEG
3	IMAGETYPE_PNG
4	IMAGETYPE_SWF
5	IMAGETYPE_PSD
6	IMAGETYPE_BMP
7	IMAGETYPE_TIFF_II (intel byte order)
8	IMAGETYPE_TIFF_MM (motorola byte order)
9	IMAGETYPE_JPC
10	IMAGETYPE_JP2
11	IMAGETYPE_JPX
12	IMAGETYPE_JB2
13	IMAGETYPE_SWC
14	IMAGETYPE_IFF
15	IMAGETYPE_WBMP
16	IMAGETYPE_XBM
17	IMAGETYPE_ICO
*/            
/*        $imagetype = exif_imagetype($filePath);
        echo $imagetype . "\n<br>";
        if ($imagetype == 2) {

            // EXIF
            $exif = exif_read_data($filePath, 0, true);
            if ($exif) {
                foreach ($exif as $key => $section) {
                    foreach ($section as $name => $val) {
                        echo "$key.$name: $val\n<br>";
                    }
                }
            }

            // IPTC
            $size = getimagesize($filePath, $info);
            if(is_array($info)) {
                $iptc = iptcparse($info["APP13"]);
                foreach (array_keys($iptc) as $s) {
                    $c = count ($iptc[$s]);
                    for ($i=0; $i <$c; $i++)
                    {
                        echo $s.' = '.$iptc[$s][$i].'<br>';
                    }
                }
            }

        }
*/

/*        
        $extensionarr = explode('.', $fileName);
        $meta = array();
        $meta['extension'] = strtolower($extensionarr[count($extensionarr) - 1]);
        $meta['size'] = filesize($filePath);
        $meta['isImage'] = (in_array($meta['extension'], $this->imageFileTypes) ? true : false);
    
        if (!$meta['isImage']) {
            return $meta;
        }
    
        if ($meta['extension'] == 'swf') {
            $meta['isImage'] = false;
        }
    
        $imgInfo = getimagesize($filePath);
        if (!is_array($imgInfo)) {
            return $meta;
        }
    
        $meta['width'] = $imgInfo[0];
        $meta['height'] = $imgInfo[1];
    
        if ($imgInfo[1] < $imgInfo[0]) {
            $meta['format'] = 'landscape';
        } elseif ($imgInfo[1] > $imgInfo[0]) {
            $meta['format'] = 'portrait';
        } else {
            $meta['format'] = 'square';
        }
    
*/
        return $meta;

    }    
}
