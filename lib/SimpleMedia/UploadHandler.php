<?php
/**
 * SimpleMedia.
 *
 * @copyright Erik Spaan & Axel Guckelsberger (ESP)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package SimpleMedia
 * @author Erik Spaan & Axel Guckelsberger <erik@zikula.nl>.
 * @link https://github.com/zikula-ev/SimpleMedia
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.6.1 (http://modulestudio.de).
 */

/**
 * Upload handler implementation class.
 */
class SimpleMedia_UploadHandler extends SimpleMedia_Base_UploadHandler
{
    // feel free to add your upload handler enhancements here

    /**
     * @var array List of file types to be considered as audio.
     */
    protected $audioFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $videoFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $ebookFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $rawImageFileTypes;

    /**
     * @var array List of file types to be considered as video.
     */
    protected $geoFileTypes;

    /**
     * @var array List of file types to be considered as documents.
     */
    protected $documentFileTypes;

    /**
     * Constructor initialising the supported object types.
     */
    public function __construct()
    {
        parent::__construct();
        
        // see for instance http://en.wikipedia.org/wiki/List_of_file_formats
        $this->imageFileTypes = array('gif', 'jpeg', 'jpg', 'png', 'tif', 'tiff', 'bmp'); // raster images
        $this->audioFileTypes = array('aac', 'mp3', 'wav', 'aif', 'mid');
        $this->videoFileTypes = array('mpg', 'mpeg', 'mp4', 'mov', 'wmv', 'avi', 'swf', 'flv', 'rm', 'f4v', 'h264');
        $this->ebookFileTypes = array('epub', 'mobi');
        $this->rawImageFileTypes = array('dng', 'cr2', 'nef');
        $this->geoFileTypes = array('kml', 'gpx');

        $dtpFileTypes = array('qxd', 'fm', 'indd');
        $otherimageFileTypes = array('psd', 'eps', 'ps', 'ai', 'svg', 'odg', 'emf', 'dwg', 'dxf');
        $this->documentFileTypes = array_merge(
            array('pdf', 'doc', 'xls', 'ppt', 'docx', 'xlsx', 'pptx', 'odt', 'ods', 'odp', 'pages', 'numbers', 'key', 'keynote', 'txt', 'rtf', 'csv', 'tex'), 
            $otherimageFileTypes, $dtpFileTypes
        );
        // zip and other package files will go into other
		
		// use modvar in kBytes for file size in Bytes
        $this->allowedFileSizes = array('medium' => array('theFile' => ModUtil::getVar('SimpleMedia', 'maxUploadFileSize')*1024));
    }

    /**
     * Determines the allowed file extensions for a given object type.
     * OVERRIDE: using allowedExtensions
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fieldName  Name of upload field.
     * @param string $extension  Input file extension.
     *
     * @return array the list of allowed file extensions
     */
    protected function isAllowedFileExtension($objectType, $fieldName, $extension)
    {
        // determine the allowed extensions
        $allowedExtensions = array();
        switch ($objectType) {
            case 'medium':
                $allowedExtensions = explode(',', str_replace(' ', '', ModUtil::getVar('SimpleMedia', 'allowedExtensions')));
                    break;
        }
    
        if (count($allowedExtensions) > 0) {
            if (!in_array($extension, $allowedExtensions)) {
                return false;
            }
        }
    
        if (in_array($extension, $this->forbiddenFileTypes)) {
            return false;
        }
    
        return true;
    }
    
    /**
     * Read meta data from a certain file.
     * OVERRIDE 
	 * - adding exif/iptc meta vars
	 * - storing some exif parameters in the medium settings, like GPS coordinates, TBD
	 * - store copyright in the MediumMetaData rights field, TBD
	 * - ...
     *
     * @param string $fileName  Name of file to be processed.
     * @param string $filePath  Path to file to be processed.
     *
     * @return array collected meta data
     */
    public function readMetaDataForFile($fileName, $filePath)
    {
        $meta = array();
        if (empty($fileName)) {
            return $meta;
        }
    
		// extract file information 
        $extensionarr = explode('.', $fileName);
        $meta = array();
        $meta['extension'] = strtolower($extensionarr[count($extensionarr) - 1]);
        $meta['size'] = filesize($filePath);
		
		// check for extensions and store media type
        $meta['isImage'] = (in_array($meta['extension'], $this->imageFileTypes) ? true : false);
        $meta['isAudio'] = (in_array($meta['extension'], $this->audioFileTypes) ? true : false);
        $meta['isVideo'] = (in_array($meta['extension'], $this->videoFileTypes) ? true : false);
        $meta['isEbook'] = (in_array($meta['extension'], $this->ebookFileTypes) ? true : false);
        $meta['isRawImage'] = (in_array($meta['extension'], $this->rawImageFileTypes) ? true : false);
        $meta['isGeo'] = (in_array($meta['extension'], $this->geoFileTypes) ? true : false);
        $meta['isDoc'] = (in_array($meta['extension'], $this->documentFileTypes) ? true : false);
        // Add extra identification for pdf files, they are doc as well as pdf.
        $meta['isPdf'] = ($meta['extension'] == 'pdf') ? true : false;
    
		// proceed only with extra meta extraction if the file is an image
        if (!$meta['isImage']) {
            return $meta;
        }
    
		// extract imageSize and imageInfo
        $imageSize = getimagesize($filePath, $imageInfo);
        if (!is_array($imageSize)) {
            return $meta;
        }
    
		// extract image dimensions 
        $meta['width'] = $imageSize[0];
        $meta['height'] = $imageSize[1];
    
		// image format
        if ($meta['height'] < $meta['width']) {
            $meta['format'] = 'landscape';
        } elseif ($meta['height'] > $meta['width']) {
            $meta['format'] = 'portrait';
        } else {
            $meta['format'] = 'square';
        }

        // Extract EXIF/IPTC information only if PHP supports exif functions
        if (!function_exists('exif_read_data') || !function_exists('exif_imagetype')) {
			LogUtil::registerStatus('No EXIF/IPTC extraction done on the uploaded image, since PHP exif functions are not available');
            return $meta;
        }

        // extract imagetype and mimetype
        $meta['imagetype'] = exif_imagetype($filePath);
        $meta['mimetype'] = image_type_to_mime_type($meta['imagetype']);

		$meta['exif'] = array();
		$meta['iptc'] = array();

        if ($meta['imagetype'] == SimpleMedia_Util_Image::IMAGETYPE_JPEG ||
            $meta['imagetype'] == SimpleMedia_Util_Image::IMAGETYPE_TIFF_II ||
            $meta['imagetype'] == SimpleMedia_Util_Image::IMAGETYPE_TIFF_MM) {

            // Read EXIF data in array form with no minimum sections in exif required
            $meta['exif'] = exif_read_data($filePath, 0, true);
            if ($meta['exif']) {
                foreach ($meta['exif'] as $key => $section) {
                    foreach ($section as $name => $val) {
                        // echo "$key.$name: $val\n<br>";
						// Store differently ?
                    }
                }
            }

            // read IPTC data
            if (isset($imageInfo) && is_array($imageInfo)) {
                $meta['iptc'] = iptcparse($imageInfo["APP13"]);
                foreach (array_keys($meta['iptc']) as $s) {
                    $c = count ($iptc[$s]);
                    for ($i=0; $i<$c; $i++) {
                        //echo $s.' = '.$iptc[$s][$i].'<br>';
						// Store in other form ?
                    }
                }
            }
        }
	
/*
http://stackoverflow.com/questions/1578169/how-can-i-read-xmp-data-from-a-jpg-with-php
<?php

function getXmpData($filename, $chunkSize)
{
    if (!is_int($chunkSize)) {
        throw new RuntimeException('Expected integer value for argument #2 (chunkSize)');
    }

    if ($chunkSize < 12) {
        throw new RuntimeException('Chunk size cannot be less than 12 argument #2 (chunkSize)');
    }

    if (($file_pointer = fopen($filename, 'r')) === FALSE) {
        throw new RuntimeException('Could not open file for reading');
    }

    $startTag = '<x:xmpmeta';
    $endTag = '</x:xmpmeta>';
    $buffer = NULL;
    $hasXmp = FALSE;

    while (($chunk = fread($file_pointer, $chunkSize)) !== FALSE) {

        if ($chunk === "") {
            break;
        }

        $buffer .= $chunk;
        $startPosition = strpos($buffer, $startTag);
        $endPosition = strpos($buffer, $endTag);

        if ($startPosition !== FALSE && $endPosition !== FALSE) {
            $buffer = substr($buffer, $startPosition, $endPosition - $startPosition + 12);
            $hasXmp = TRUE;
            break;
        } elseif ($startPosition !== FALSE) {
            $buffer = substr($buffer, $startPosition);
            $hasXmp = TRUE;
        } elseif (strlen($buffer) > (strlen($startTag) * 2)) {
            $buffer = substr($buffer, strlen($startTag));
        }
    }

    fclose($file_pointer);
    return ($hasXmp) ? $buffer : NULL;
}
*/	
	
        return $meta;
    }
}
